function [files_in,files_out,opt] = niak_brick_stability_consensus(files_in,files_out,opt)
% Generate consensus clusters based on estimated stability matrices
%
% SYNTAX:
% [FILES_IN,FILES_OUT,OPT] = NIAK_BRICK_STABILITY_CONSENSUS(FILES_IN,FILES_OUT,OPT)
%
% _________________________________________________________________________
% INPUTS:
% FILES_IN
%   STAB
%       (string or cell of strings) path or paths to the stability matrices
%       generated by the batches.
%
%   ROI
%       (string) path to the file containing the region growing results
%
% FILES_OUT
%   (string, optional) the path to the output .mat file
%
% OPT
%   (structure) with the following fields:
%
%   SCALE
%       (vector of K integers) the target scales to be
%       investigated. This has to be specified
%
%   SCALE_TARGET
%       (vector, optional) the target scales to be investigated when
%       OPT.FLAG_FIX is set
%
%   CLUSTERING
%      (structure, optional) with the following fields :
%
%      TYPE
%         (string, default 'hierarchical') the clustering algorithm
%         Available options :
%            'hierarchical': a HAC based on correlation.
%
%      OPT
%         (structure, optional) options that will be  sent to the
%         clustering command. The exact list of options depends on
%         CLUSTERING.TYPE:
%         'hierarchical' : see OPT in NIAK_HIERARCHICAL_CLUSTERING
%
%   NAME_STAB
%      (string, default 'stab') the name of the variable that contains
%      the stability matrix.
%
%   NAME_ROI
%       (string, default 'roi') the name of the variable in FILES_IN.ROI
%       that contains the partition into atoms
%
%   RAND_SEED
%      (scalar, default []) The specified value is used to seed the random
%      number generator with PSOM_SET_RAND_SEED. If left empty, no action
%      is taken.
%
%   FLAG_VERBOSE
%      (boolean, default true) turn on/off the verbose.
%
%   FLAG_FIND_SCALE
%       (boolean, default false) find the optimal K clusters for L
%
%   FLAG_TEST
%      (boolean, default false) if the flag is true, the brick does not do anything
%      but updating the values of FILES_IN, FILES_OUT and OPT.
%
% _________________________________________________________________________
% OUTPUTS:
%
% The structures FILES_IN, FILES_OUT and OPT are updated with default
% valued. If OPT.FLAG_TEST == 0, the specified outputs are written.
%
% _________________________________________________________________________
% COMMENTS:
%
% Copyright (c) Pierre Bellec, Sebastian Urchs
%   Centre de recherche de l'institut de Gériatrie de Montréal
%   Département d'informatique et de recherche opérationnelle
%   Université de Montréal, 2010-2014
%   Montreal Neurological Institute, 2014
% Maintainer : pierre.bellec@criugm.qc.ca
% See licensing information in the code.
% Keywords : clustering, surface analysis, cortical thickness, stability
%            analysis, bootstrap, jacknife.

% Permission is hereby granted, free of charge, to any person obtaining a copy
% of this software and associated documentation files (the "Software"), to deal
% in the Software without restriction, including without limitation the rights
% to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
% copies of the Software, and to permit persons to whom the Software is
% furnished to do so, subject to the following conditions:
%
% The above copyright notice and this permission notice shall be included in
% all copies or substantial portions of the Software.
%
% THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
% IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
% FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
% AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
% LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
% OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
% THE SOFTWARE.

%% TODO:

%% Initialization and syntax checks

% Syntax
if ~exist('files_in','var')||~exist('files_out','var')
    error('niak:brick','syntax: [FILES_IN,FILES_OUT,OPT] = NIAK_BRICK_STABILITY_CONSENSUS(FILES_IN,FILES_OUT,OPT).\n Type ''help niak_brick_stability_consensus'' for more info.')
end

% FILES_IN
list_fields   = { 'stab' , 'roi' };
list_defaults = { NaN    , NaN   };
files_in = psom_struct_defaults(files_in,list_fields,list_defaults);

% FILES_OUT
if ~ischar(files_out)
    error('FILES_OUT should be a string!');
end

% Options
if nargin < 3
    opt = struct;
end

opt_clustering.type   = 'hierarchical';
opt_clustering.opt    = struct();

list_fields   = { 'clustering'   , 'name_stab' , 'name_roi' , 'flag_verbose' , 'scale' , 'rand_seed' , 'flag_test' , 'flag_find_scale' , 'scale_target' };
list_defaults = { opt_clustering , 'stab'      , 'roi'      , true           , NaN     , []          , false       , false             , []          };
opt = psom_struct_defaults(opt,list_fields,list_defaults);

opt.clustering.opt.flag_verbose = opt.flag_verbose;
opt.clustering = psom_struct_defaults(opt.clustering,{'type','opt'},{'hierarchical',struct});

% If the find_scale flag is set, check if any scales are provided to search
if opt.flag_find_scale && isempty(opt.scale_target)
    error(['FLAG_FIND is set but there are no target scales '...
           'selected for search. Please supply scales to OPT.SCALE_TARGET!\n']);
end

% If the test flag is true, stop here !
if opt.flag_test == 1
    return
end

%% Seed the random generator
if ~isempty(opt.rand_seed)
    psom_set_rand_seed(opt.rand_seed);
end

%% Read the data
roi = load(files_in.roi);
part_roi = roi.(opt.name_roi);

data = load(files_in.stab);
if ~isfield(data,opt.name_stab)
    error('I could not find the variable called %s in the file %s',...
          opt.name_stab, files_in.stab)
else
    stab = data.(opt.name_stab);
end

%% Generate consensus clustering
if isempty(opt.scale)
    error(['Please specify the scale of the stability matrix in OPT.SCALE. '...
           'Current scale is empty.\n']);
end

% Perform the consensus clustering
opt_c.clustering = opt.clustering;
opt_c.flag_verbose = opt.flag_verbose;
opt_c.nb_classes = opt.scale;

[tmp_part, order,sil,...
 intra, inter, hier, nb_classes] = niak_consensus_clustering(stab,opt_c);

for sc_id = 1:length(opt.scale);
    mat = niak_vec2mat(stab(:,sc_id));
    [sil(:,sc_id),...
     intra(:,sc_id), inter(:,sc_id)] = niak_build_avg_silhouette(mat,...
                                                                 hier{sc_id},...
                                                                 false);
end

% Bring the partition back into the original space
num_part = numel(opt.scale);
V = length(part_roi);
part = zeros(V,num_part);
for part_index = 1:num_part
    part(:,part_index) = niak_part2vol(tmp_part(:, part_index),part_roi);
end

if opt.flag_find_scale
    % Set the fixed neighbourhood
    neigh = [0.7,1.3];
    
    [sil_max, scales_max] = niak_build_max_sil(sil, opt.scale(:), neigh, 1);
    
    % Find the optimal stochastic scales for the target scales
    scale = scales_max(opt.scale_target)';
    % Find the indices of the optimal stochastic scales in opt.scale
    k_ind = arrayfun(@(x) find(opt.scale == x,1,'first'), scale);
    % Truncate the inputs to reflect the adapted stochastic scales
    sil = sil(:, k_ind);
    part = part(:, k_ind);
    stab = stab(:, k_ind);
    hier = hier(k_ind);
    save(files_out,'part','scale','order','sil','intra','inter','hier','stab','nb_classes');
    
else
    %% Save the results
    scale = opt.scale;
    save(files_out,'part','scale','order','sil','intra','inter','hier','stab','nb_classes');
end